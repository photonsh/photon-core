{"name":"Racket","scopeName":"source.racket","comment":"\nThe foldings do not currently work the way I want them to. This\nmay be a limitation of the way they are applied rather than the\nregexps in use. Nonetheless, the foldings will end on the last\nidentically indented blank line following an s-expression. Not\nideal perhaps, but it works. Also, the #illegal pattern never\nmatches an unpaired ( as being illegal. Why?! -- Rob Rix\n\nOk, hopefully this grammar works better on quoted stuff now.  It\nmay break for fancy macros, but should generally work pretty\nsmoothly.  -- Jacob Rus\n\nI have attempted to get this under control but because of the way folding\nand indentation interact in Textmate, I am not sure if it is possible. In the\nmeantime, I have implemented Python-style folding anchored at newlines.\nAdditionally, I have made some minor improvements to the numeric constant\nhighlighting. Next up is square bracket expressions, I guess, but that\nshould be trivial. -- ozy`\n","fileTypes":["rkt","￿"],"firstLineMatch":"^#!\\s*/.*\\bracket","foldingStartMarker":"(?x)^ [ \t]* (\n\t  (?<par>\n\t    ( [^()\n]++ | ( g<par> )? )*+\n\t  )\n\t$","foldingStopMarker":"^\\s*$","patterns":[{"include":"#comment"},{"include":"#sexp"},{"include":"#string"},{"include":"#language-functions"},{"include":"#quote"},{"include":"#constants"},{"include":"#illegal"}],"repository":{"comment":{"patterns":[{"captures":{"1":{"name":"punctuation.definition.comment.racket"}},"match":"(;).*$\\n?","name":"comment.line.semicolon.racket"},{"begin":"#\\|","captures":{"0":{"name":"punctuation.definition.comment.racket"}},"end":"\\|#","name":"comment.multiline.racket"}]},"constants":{"patterns":[{"match":"#(t(rue)?|f(alse)?)","name":"constant.language.boolean.racket"},{"match":"(#:)([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)(?=[\\s\\)])","name":"constant.keyword.racket"},{"match":"(?<=[\\(\\s])((#e|#i)?[0-9]+(\\.[0-9]+)?|(#x)[0-9a-fA-F]+|(#o)[0-7]+|(#b)[01]+)(?=[\\s;()'\",\\[\\]])","name":"constant.numeric.racket"}]},"illegal":{"match":"[()]","name":"invalid.illegal.parenthesis.racket"},"language-functions":{"patterns":[{"match":"(?x)\n\t\t\t\t\t\t(?<=(\\(|\\[)) # preceded by ( or [\n\t\t\t\t\t\t( do|or|and|else|quasiquote|begin|if|case|set!|\n\t\t\t\t\t\t  cond|let|unquote|define(-datatype|-struct|-values)*|let\\*|unquote-splicing|delay|\n\t\t\t\t\t\t  letrec)\n\t\t\t\t\t\t(?=(\\s|\\())","name":"keyword.control.racket"},{"comment":"\nThese functions run a test, and return a boolean\nanswer.\n","match":"(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( char-alphabetic|char-lower-case|char-numeric|\n\t\t\t\t\t\t  char-ready|char-upper-case|char-whitespace|\n\t\t\t\t\t\t  (?:char|string)(?:-ci)?(?:=|<=?|>=?)|\n\t\t\t\t\t\t  atom|boolean|bound-identifier=|char|complex|\n\t\t\t\t\t\t  identifier|integer|symbol|free-identifier=|inexact|\n\t\t\t\t\t\t  eof-object|exact|list|(?:input|output)-port|pair|\n\t\t\t\t\t\t  real|rational|zero|vector|negative|odd|null|string|\n\t\t\t\t\t\t  eq|equal|eqv|even|number|positive|procedure\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(\\?)\t\t# name ends with ? sign\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n","name":"support.function.boolean-test.racket"},{"comment":"\nThese functions change one type into another.\n","match":"(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( char->integer|exact->inexact|inexact->exact|\n\t\t\t\t\t\t  integer->char|symbol->string|list->vector|\n\t\t\t\t\t\t  list->string|identifier->symbol|vector->list|\n\t\t\t\t\t\t  string->list|string->number|string->symbol|\n\t\t\t\t\t\t  number->string\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n","name":"support.function.convert-type.racket"},{"comment":"\nThese functions are potentially dangerous because\nthey have side-effects which could affect other\nparts of the program.\n","match":"(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( set-(?:car|cdr)|\t\t\t\t # set car/cdr\n\t\t\t\t\t\t  (?:vector|string)-(?:fill|set) # fill/set string/vector\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(!)\t\t\t# name ends with ! sign\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n","name":"support.function.with-side-effects.racket"},{"comment":"\n+, -, *, /, =, >, etc.\n","match":"(?<=(\\s|\\())( >=?|<=?|=|[*/+-])(?=(\\s|\\())","name":"keyword.operator.arithmetic.racket"},{"match":"(?x)\n\t\t\t\t\t\t(?<=(\\s|\\()) # preceded by space or (\n\t\t\t\t\t\t( append|apply|approximate|\n\t\t\t\t\t\t  call-with-current-continuation|call/cc|catch|\n\t\t\t\t\t\t  construct-identifier|define-syntax|display|foo|\n\t\t\t\t\t\t  for-each|force|cd|gen-counter|gen-loser|\n\t\t\t\t\t\t  generate-identifier|last-pair|length|let-syntax|\n\t\t\t\t\t\t  letrec-syntax|list|list-ref|list-tail|load|log|\n\t\t\t\t\t\t  macro|magnitude|map|map-streams|max|member|memq|\n\t\t\t\t\t\t  memv|min|newline|nil|not|peek-char|rationalize|\n\t\t\t\t\t\t  read|read-char|return|reverse|sequence|substring|\n\t\t\t\t\t\t  syntax|syntax-rules|transcript-off|transcript-on|\n\t\t\t\t\t\t  truncate|unwrap-syntax|values-list|write|write-char|\n\n\t\t\t\t\t\t  # cons, car, cdr, etc\n\t\t\t\t\t\t  cons|c(a|d){1,4}r|\n\n\t\t\t\t\t\t  # unary math operators\n\t\t\t\t\t\t  abs|acos|angle|asin|assoc|assq|assv|atan|ceiling|\n\t\t\t\t\t\t  cos|floor|round|sin|sqrt|tan|\n\t\t\t\t\t\t  (?:real|imag)-part|numerator|denominator\n\n\t\t\t\t\t\t  # other math operators\n\t\t\t\t\t\t  modulo|exp|expt|remainder|quotient|lcm|\n\n\t\t\t\t\t\t  # ports / files\n\t\t\t\t\t\t  call-with-(?:input|output)-file|\n\t\t\t\t\t\t  (?:close|current)-(?:input|output)-port|\n\t\t\t\t\t\t  with-(?:input|output)-from-file|\n\t\t\t\t\t\t  open-(?:input|output)-file|\n\n\t\t\t\t\t\t  # char-«foo»\n\t\t\t\t\t\t  char-(?:downcase|upcase|ready)|\n\n\t\t\t\t\t\t  # make-«foo»\n\t\t\t\t\t\t  make-(?:polar|promise|rectangular|string|vector)\n\n\t\t\t\t\t\t  # string-«foo», vector-«foo»\n\t\t\t\t\t\t  string(?:-(?:append|copy|length|ref))?|\n\t\t\t\t\t\t  vector(?:-length|-ref)\n\n\t\t\t\t\t\t\t# additional keyword-like functions\n\t\t\t\t\t\t\t|for|when|printf|require\n\t\t\t\t\t\t)\n\t\t\t\t\t\t(?=(\\s|\\()) # followed by space or (\n","name":"support.function.general.racket"}]},"quote":{"comment":"\nWe need to be able to quote any kind of item, which creates\na tiny bit of complexity in our grammar.  It is hopefully\nnot overwhelming complexity.\n\nNote: the first two matches are special cases.  quoted\nsymbols, and quoted empty lists are considered constant.other\n\n","patterns":[{"captures":{"1":{"name":"punctuation.section.quoted.symbol.racket"}},"match":"(?x)\n\t\t\t\t\t\t(')s*\n\t\t\t\t\t\t([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\n","name":"constant.other.symbol.racket"},{"captures":{"1":{"name":"punctuation.section.quoted.empty-list.racket"},"2":{"name":"meta.expression.racket"},"3":{"name":"punctuation.section.expression.begin.racket"},"4":{"name":"punctuation.section.expression.end.racket"}},"match":"(?x)\n\t\t\t\t\t\t(')s*\n\t\t\t\t\t\t((()s*()))\n","name":"constant.other.empty-list.schem"},{"begin":"(')\\s*","beginCaptures":{"1":{"name":"punctuation.section.quoted.racket"}},"comment":"quoted double-quoted string or s-expression","end":"(?=[\\s()])|(?<=\\n)","name":"string.other.quoted-object.racket","patterns":[{"include":"#quoted"}]}]},"quote-sexp":{"begin":"(?<=\\()\\s*(quote)\\b\\s*","beginCaptures":{"1":{"name":"keyword.control.quote.racket"}},"comment":"\nSomething quoted with (quote «thing»).  In this case «thing»\nwill not be evaluated, so we are considering it a string.\n","contentName":"string.other.quote.racket","end":"(?=[\\s)])|(?<=\\n)","patterns":[{"include":"#quoted"}]},"quoted":{"patterns":[{"include":"#string"},{"begin":"(\\()","beginCaptures":{"1":{"name":"punctuation.section.expression.begin.racket"}},"end":"(\\))","endCaptures":{"1":{"name":"punctuation.section.expression.end.racket"}},"name":"meta.expression.racket","patterns":[{"include":"#quoted"}]},{"include":"#quote"},{"include":"#illegal"}]},"sexp":{"begin":"(\\()","beginCaptures":{"1":{"name":"punctuation.section.expression.begin.racket"}},"end":"(\\))(\\n)?","endCaptures":{"1":{"name":"punctuation.section.expression.end.racket"},"2":{"name":"meta.after-expression.racket"}},"name":"meta.expression.racket","patterns":[{"include":"#comment"},{"begin":"(?x)\n\t\t\t\t\t\t(?<=\\()       # preceded by (\n\t\t\t\t\t\t(define)\\s+   # define\n\t\t\t\t\t\t(\\()          # list of parameters\n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\n\t\t\t\t\t\t  ((\\s+\n\t\t\t\t\t\t    ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t   )*\n\t\t\t\t\t\t  )\\s*\n\t\t\t\t\t\t(\\))\n","captures":{"1":{"name":"keyword.control.racket"},"2":{"name":"punctuation.definition.function.racket"},"3":{"name":"entity.name.function.racket"},"4":{"name":"variable.parameter.function.racket"},"7":{"name":"punctuation.definition.function.racket"}},"end":"(?=\\))","name":"meta.declaration.procedure.racket","patterns":[{"include":"#comment"},{"include":"#sexp"},{"include":"#illegal"}]},{"begin":"(?x)\n\t\t\t\t\t\t(?<=\\() # preceded by (\n\t\t\t\t\t\t(lambda|λ)\\s+\n\t\t\t\t\t\t(\\() # opening paren\n\t\t\t\t\t\t((?:\n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t  \\s+\n\t\t\t\t\t\t)*(?:\n\t\t\t\t\t\t  ([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*|[._])\n\t\t\t\t\t\t)?)\n\t\t\t\t\t\t(\\)) # closing paren\n","captures":{"1":{"name":"keyword.control.racket"},"2":{"name":"punctuation.definition.variable.racket"},"3":{"name":"variable.parameter.racket"},"6":{"name":"punctuation.definition.variable.racket"}},"comment":"\nNot sure this one is quite correct.  That s* is\nparticularly troubling\n","end":"(?=\\))","name":"meta.declaration.procedure.racket","patterns":[{"include":"#comment"},{"include":"#sexp"},{"include":"#illegal"}]},{"begin":"(?<=\\()(define)\\s([[:alnum:]][[:alnum:]!$%&*+-./:<=>?@^_~]*)\\s*.*?","captures":{"1":{"name":"keyword.control.racket"},"2":{"name":"variable.other.racket"}},"end":"(?=\\))","name":"meta.declaration.variable.racket","patterns":[{"include":"#comment"},{"include":"#sexp"},{"include":"#illegal"}]},{"include":"#quote-sexp"},{"include":"#quote"},{"include":"#language-functions"},{"include":"#string"},{"include":"#constants"},{"match":"(?<=[\\(\\s])(#\\\\)(space|newline|tab)(?=[\\s\\)])","name":"constant.character.named.racket"},{"match":"(?<=[\\(\\s])(#\\\\)x[0-9A-F]{2,4}(?=[\\s\\)])","name":"constant.character.hex-literal.racket"},{"match":"(?<=[\\(\\s])(#\\\\).(?=[\\s\\)])","name":"constant.character.escape.racket"},{"comment":"\nthe . in (a . b) which conses together two elements\na and b. (a b c) == (a . (b . (c . nil)))\n","match":"(?<=[ ()])\\.(?=[ ()])","name":"punctuation.separator.cons.racket"},{"include":"#sexp"},{"include":"#illegal"}]},"string":{"begin":"(\")","beginCaptures":{"1":{"name":"punctuation.definition.string.begin.racket"}},"end":"(\")","endCaptures":{"1":{"name":"punctuation.definition.string.end.racket"}},"name":"string.quoted.double.racket","patterns":[{"match":"\\\\.","name":"constant.character.escape.racket"}]}}}